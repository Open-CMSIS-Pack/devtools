/*
 * Copyright (c) 2026 Microchip Technology Inc. and its subsidiaries.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the License); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm")
OUTPUT_ARCH(arm)
SEARCH_DIR(.)

/*
 *  Define the __XC32_RESET_HANDLER_NAME macro on the command line when you
 *  want to use a different name for the Reset Handler function.
 */
#ifndef __XC32_RESET_HANDLER_NAME
#define __XC32_RESET_HANDLER_NAME Reset_Handler
#endif /* __XC32_RESET_HANDLER_NAME */

_start = __XC32_RESET_HANDLER_NAME;
ENTRY(__XC32_RESET_HANDLER_NAME)

/* ----------------------------------------------------------------------------
  Memory definition
 *----------------------------------------------------------------------------*/
MEMORY
{
  rom  (rx)  : ORIGIN = __ROM0_BASE, LENGTH = __ROM0_SIZE
  ram  (rwx) : ORIGIN = __RAM0_BASE, LENGTH = __RAM0_SIZE
}

#ifndef CODE_REGION
# if __ROM0_SIZE > 0
#   define CODE_REGION rom
# else
#   define CODE_REGION ram
# endif
#endif
#ifndef DATA_REGION
# define DATA_REGION ram
#endif
#ifndef VECTOR_REGION
# define VECTOR_REGION CODE_REGION
#endif

SECTIONS
{
  .vectors :
  {
    . = ALIGN(4);
    _sfixed = .;
    __Vectors = .;
    KEEP(*(.vectors .vectors.* .vectors_default .vectors_default.*))
    KEEP(*(.isr_vector))
    KEEP(*(.reset*))
    KEEP(*(.after_vectors))
    . = ALIGN(4);
  } > VECTOR_REGION

  .text :
  {
    . = ALIGN(4);
    *(.text .text.*)
    *(.glue_7t) *(.glue_7)
    *(.gnu.linkonce.r.*)
    *(.ARM.extab* .gnu.linkonce.armextab.*)


    . = ALIGN(4);
    KEEP(*(.init))
    . = ALIGN(4);
    __preinit_array_start = .;
    KEEP (*(.preinit_array))
    __preinit_array_end = .;

    . = ALIGN(4);
    __init_array_start = .;
    KEEP (*(SORT(.init_array.*)))
    KEEP (*(.init_array))
    __init_array_end = .;

    . = ALIGN(0x4);
    KEEP (*crtbegin.o(.ctors))
    KEEP (*(EXCLUDE_FILE (*crtend.o) .ctors))
    KEEP (*(SORT(.ctors.*)))
    KEEP (*crtend.o(.ctors))

    . = ALIGN(4);
    KEEP(*(.fini))

    . = ALIGN(4);
    __fini_array_start = .;
    KEEP (*(.fini_array))
    KEEP (*(SORT(.fini_array.*)))
    __fini_array_end = .;

    KEEP (*crtbegin.o(.dtors))
    KEEP (*(EXCLUDE_FILE (*crtend.o) .dtors))
    KEEP (*(SORT(.dtors.*)))
    KEEP (*crtend.o(.dtors))

    . = ALIGN(4);
    _efixed = .;           
  } > CODE_REGION

  .ARM.exidx :
  {
    PROVIDE_HIDDEN (__exidx_start = .);
    *(.ARM.exidx* .gnu.linkonce.armexidx.*)
    PROVIDE_HIDDEN (__exidx_end = .);
  } > CODE_REGION

  .copy.table :
  {
    . = ALIGN(4);
    __copy_table_start__ = .;
    LONG (__data_load__)
    LONG (__data_start__)
    LONG (__data_end__ - __data_start__)
    __copy_table_end__ = .;
  } > CODE_REGION

  .zero.table :
  {
    . = ALIGN(4);
    __zero_table_start__ = .;
    LONG (__bss_start__)
    LONG (__bss_end__ - __bss_start__)
    __zero_table_end__ = .;
  } > CODE_REGION


  __data_load__ = LOADADDR(.data);

  .data :
  {
    . = ALIGN(4);
    __data_start__ = .;
    _sdata = .;
    *(.data .data.*)
    . = ALIGN(4);
    __data_end__ = .;
    _edata = .;
  } > DATA_REGION AT > CODE_REGION

  .bss (NOLOAD) :
  {
      . = ALIGN(4);
      __bss_start__ = .;
      __bss_start = .;
      _sbss = . ;
      _szero = .;
      *(.bss .bss.*)
      *(COMMON)
      . = ALIGN(4);
      __bss_end__ = .;
      __bss_end = .;
      _ebss = . ;
      _ezero = .;
  } > DATA_REGION

  .heap (NOLOAD) :
  {
    . = ALIGN(8);
    __end__ = .;
    PROVIDE(end = .);
    . = . + 0x400;
    __HeapLimit = .;
  } > DATA_REGION

  .stack (NOLOAD) :
  {
    . = ALIGN(8);
    . = . + 0x800;
  } > DATA_REGION

  __StackTop = ORIGIN(ram) + LENGTH(ram);
  __StackLimit = __StackTop - 0x1000; 
  
  __STACK_LIMIT = __StackLimit;
  PROVIDE(__stack = __StackTop);

  . = ALIGN(4);
  _end = . ;
  _ram_end_ = ORIGIN(ram) + LENGTH(ram) -1 ;
}

