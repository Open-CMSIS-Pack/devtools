# [DRAFT] Overview

![Overview](./images/Overview.png "Overview")

The **[Open-CMSIS-Pack](https://www.open-cmsis-pack.org/index.html) Project Manager** essentially uses **Project Files** and **CMSIS-Packs** to create self-contained
CMSIS-Build input files.

The CMSIS-Pack shown on the left side provide device setup (DFP), board configuration, and other reusable software components. It should be investigated if the CMSIS-Zone concept can be integrated into the CMSIS Project Manager.  The files on the left side are typically not touched by an application programmer as they are provided by silicon vendors, board manufacturers, or the software industry.

The project setup uses YML Format that provides with a schema file validation and "intellisense" features during interactive edit, for example in VS Code.

| Project Files     | Description
|:------------------|:---------------------------------------------------------------------------------
| `*.csolution.yml` | Container for related projects.
| `*.cproject.yml`  | Build description of an independent image.
| `*.clayer.yml`    | Set of source files along with pre-configured components for reuse in different context.
| `*.csettings.yml` | Default setup for project creation. For example, could provide build-types and a default board. 

The **CMSIS Project Manager** uses the *Project Files* along with the *CMSIS-Packs* to generate:
  - `*.cproject.yml` output files that contain the effective setting. When comparing to a previous generated version, this file shows the effective changes done by a user compared to the previous setup.
  - `*.cprj` files for CMSIS-Build where a reproducible build can be made on different computers.  It lists all packs, software components, etc.
  - `script files` that are generated by a template engine (CMSIS-Zone concept) to setup linker and other application parameters (to be investigated).


# Project Examples

## Minimal Project Setup

Simple applications require just one self-contained.

**Simple Project: `Sample.cproject.yml`**
```yml
default:
  target:
    device: LPC55S69
  optimize: size
  debug: on

groups:
  - group: My files
    files:
      - file: main.c

  - group: HAL
    files:
      - file: .\hal\driver1.c

components:
  - component: Device:Startup
```

## Project Setup for Multiple Targets and Test Builds


Complex examples require frequently slightly different targets and or modifications during build, i.e. for testing. The picture below shows a setup during software development that supports:
 - Unit/Integration Testing on simulation models (call Virtual Hardware) where Virtual Drivers implement the interface to simulated I/O.
 - Unit/Integration Testing the same software setup on a physical board where Hardware Drivers implement the interface to physical I/O.
 - System Testing where the software is combined with more software components that compose the final application.

 ![Target and Build Types](./images/TargetBuild-Types.png "Target and Build Types")

As the software may share a large set of common files, provisions are required to manage such projects.  The common way in other IDE's is to add:
  - **target-types** that select a target system. In the example this would be:
    - `Virtual`: for Simulation Models.
    - `Board`: for a physical evaluation board.
    - `Production-HW`: for the system test.
  - **build-types** add the flexibility to configure each target build towards a specific testing.  It might be:
    - `Debug`: for a full debug build of the software for interactive debug.
    - `Test`: for a specific timing test using a test interface with code maximal optimization.
    - `Release`: for the final code deployment to the systems.

It is required to generate reproducible builds that can deployed on independent CI/CD test systems. To achieve that, *.the CMSIS Project Manager generates *.cprj output files with the following naming conventions:


`<projectname>.<build-type>[~target-type].cprj` this would generate for example: `Multi.Debug~Production-HW.cprj`

This enables that each target and/or build type can be identified and independently generated which provides the support for test automation. It is however not required to build every possible combination, this should be under user control.

**Flexible Builds: `Multi.cproject.yml`**

```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32U5X            # specifies device

  - type: Virtual
    board: VHT-Corstone-300     # FVP platform (appears as board)
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on

  - type: Release
    optimize: max
    debug: off

groups:
  - group: My group1
    files:
      - file: file1a.c
      - file: file1b.c
      - file: file1c.c

  - group: My group2
      - file: file2a.c

  - group: Test-Interface
    include: .Test
      - file: fileTa.c

layers:
  - layer: NUCLEO-L552ZE-Q\Board.clayer.yml   # Need to find a better way: $Board$.clayer.yml
    include: ~Board

  - layer: Production.clayer.yml
    include: ~Production-HW

  - layer: Corstone-300\Board.clayer.yml
    include: ~VHT-Corstone-300
```

## Project Setup for Related Projects

A solution combines projects that can be generated independently and therefore manages related projects. The picture below shows a system that is composed of:
  - Project A: that implements a time-critical control algorithm running on a independent processor #2.
  - Project B: which is a diagram of a cloud connected IoT application with Machine Learning (ML) functionality.
  - Project C: that is the data model of the Machine Learning algorithm and separate to allow independent updates.
  - Project D: that implements the device security (for example with TF-M that runs with TrustZone in secure mode).

In addition such systems may have a boot-loader that can be also viewed as another independent project.

 ![Related Projects of an Embedded System](./images/Solution.png "Related Projects of an Embedded System")

To manage the complexity of such related a projects, the `*.csolution.yml` file is introduced. At this level the `target-types` and `build-types` may be managed, so that a common set is available across the system. However it should be also possible to add project specific `build-types` at project level.  (tdb: `target-types` might be only possible at solution level).

**Related Projects `iot-product.csolution.yml`**

```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32U5X          # specifies device
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on
    
solution:
  - project: \security\TFM.cproject.yml
    type: .Release
  - project: \application\MQTT_AWS.cproject.yml
  - project: \bootloader\Bootloader.cproject.yml
    exclude: ~Virtual
```

# YML Syntax

## General Properties

The keywords below can be used at top-level of `[defaults].csettings.yml`, `*.csolution.yml`, and `*.cproject.yml`. Some of settings can be overwritten on various levels. 

Keyword     | Description
:-----------|:------------------------------------
`compiler:` | Selection of the toolchain used for the project, i.e. `GCC`, `AC6`, `IAR`.
`device:`   | Unique device name, optionally with vendor. Format: `[<vendor>::]<device>`. Examples: `NXP::LPC55S69` or `STM32L552RCT6`
`board:`    | Unique board name, optionally with vendor. Format: `[<vendor>::]<board>`. Examples: `NXP::LPCxpresso55S69` or `NUCLEO-L552ZE-Q`.
`optimize:` | Generic optimize levels (max, size, speed, debug, tbd, ...), mapped to the toolchain by CMSIS-Build.
`debug:`    | Generic control for the generation of debug information (on, off, tbd, ...), mapped to the toolchain by CMSIS-Build.
`defines:`  | Settings for the code generation tools that are passed via the command line and result in #define.
`misc:`     | Literal tool-specific controls (tbd variants `misc-c`, `misc-ar`, ... needed?)

**Note:** `defines:` and `misc:` are additive. Other options overwrite previous settings.

## Target and Build Types

The section [Project setup for multiple targets and test builds](.\#project-setup-for-multiple-targets-and-test-builds) describes the concept of  `target-types` and `build-types`.  These *types* can be defined in the following files in the folloing order:
 1.  `default.csettings.yml`  where it defines global *types*, such as *Debug* and *Release* build.
 2. `*.csolution.yml` where it specifies the build and target *types* of the complete system.
 3. `*.cproject.yml` where it may add specific *types* for an project (tbd are target types allowed when part of a solution?)

The *`target-type`* and *`build-type`* definitions are additive, but an attempt to redefine an already existing type results in an error.

YML structure:
```yml
target-types:          # Start a list of target type declarations
  - type:              # name of the target type (required)
    board:             # board specification (optional)
    device:            # device specificaiton (optional)         
    compiler:          # toolchain specification (optional) 
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # settings for code generation that results in #define (optional)
    misc:              # Literal tool-specific controls

build-types:           # Start a list of build type declarations
  - type:              # name of the build type (required)
    compiler:          # toolchain specification (optional) 
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # settings for code generation that results in #define (optional)
    misc:              # Literal tool-specific controls
```

**Example:**
```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32U5X          # specifies device
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on
```

## Include or Exclude

Depending on a *`target-type`* or *`build-type`* selection it is also possible to include or exclude *items* in the build process.

Keyword      | Description
:------------|:------------------------------------
`include:`   | A *type list* that adds an *item* for a specific target or build *type* or a list of *types*.
`exclude:`   | A *type list* that removes an *item* for a specific target or build *type* or a list of *types*.

It is possible to specify only a `<build-type>`, only a `<target-type>` or a combination of `<build-type>` and `<target-type>`. It is also possible to provide a list of *build* and *target* types. The *type list syntax* for `include:` or `exclude:` is:

`[.<build-type>][~<target-type>] [, [.<build-type>]~[<target-type>]] [, ...]`

**Examples:**
```yml
include:  .Test                            # add item for build-type: Test (any target-type)
exclude:  ~Virtual                         # remove item for target-type: Virtual (any build-type)
exclude:  .Release~Virtual                 # remove item for build-type: Release with target-type: Virtual
include:  .Debug, .Release~Production-HW   # add for build-type: Debug and build-type: Release / target-type: Production-HW
```

The keyword `include:` or `exclude:` can be applied to the following list keywords:

Keyword      | Description
:------------|:------------------------------------
`project:`   | At `solution:` level it is possible to control inclusion of project.
`group:`     | At `group:` level it is possible to control inclusion of a file group.
`file:`      | At `file:` level it is possible to control inclusion of a file.
`layer:`     | At `layer:` level it is possible to control inclusion of a software layer.
`component:` | At `component:` level it is possible to control inclusion of a software component.


## Groups and Files

YML structure:
```yml
groups:                # Start a list of groups
  - group:             # name of the group
    include:           # include group for a list of *build* and *target* types.
    exclude:           # exclude group for a list of *build* and *target* types.
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # settings for code generation that results in #define (optional)
    misc:              # Literal tool-specific controls
    groups:            # Start a nested list of groups
      - group:         # name of the group
         :
    files:             # Start a nested list of files
      - file:          # file name along with path
        include:        # include group for a list of *build* and *target* types.
        exclude:       # exclude group for a list of *build* and *target* types.
        optimize:      # optimize level for code generation (optional)
        debug:         # generation of debug information (optional)
        defines:       # settings for code generation that results in #define (optional)
        misc:          # Literal tool-specific controls
```

**Example:**

```yml
groups:
  - group:  "Main File Group"
    exclude: .Release~Virtual, .Test-DSP~Virtual, ~Board
    files: 
      - file: file1a.c
      - file: file1b.c
        defines:
          - define: a=1
          - undefine: b
        optimize: size

  - group: "Other File Group"
    files:
      - file: file2a.c
        include: ~Virtual
        defines: 
          - define: test=2
      - file: file2a.c
        exclude: ~Virtual
      - file: file2b.c

  - group: "Nested Group"
    groups:
      - group: Subgroup1
        files:
          - file: file-sub1-1.c
          - file: file-sub1-2.c
      - group: Subgroup2
        files:
          - file: file-sub2-1.c
          - file: file-sub2-2.c
```

## Components
Todo:

## Layers 
Todo:

## Defines
Todo:

## Solution: Collection of related Projects

The section [Project setup for related projects](.\#project-setup-for-related-projects) describes the collection of related projects.  The file `*.csolution.yml` describes the relationship of this projects.  This file may also define [Target and Build Types](.\#target-and-build-types) before the section `solution:`.

The YML structure of the section `solution:` is:

```yml
solution:              # Start a list of projects.
  - project:           # path to the project file (required).
    include:           # include project for a list of *build* and *target* types (optional).
    exclude:           # exclude project for a list of *build* and *target* types (optional).
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # settings for code generation that results in #define (optional)
    misc:              # Literal tool-specific controls
```

## project
Todo:

## processor (or platform)
Todo:


# CMSIS-Zone Integration
Todo: