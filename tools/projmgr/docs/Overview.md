# [DRAFT] Overview

![Overview](./images/Overview.png "Overview")

The **[Open-CMSIS-Pack](https://www.open-cmsis-pack.org/index.html) Project Manager** essentially uses **Project Files** and **CMSIS-Packs** to create self-contained
CMSIS-Build input files.

The software packs in *CMSIS-Pack Format* shown on the left side provide device setup (via Device Family Pack (DFP)), board configuration (via Board Support Pack (BSP)), and other reusable software components. It should be investigated if the CMSIS-Zone concept can be integrated into the CMSIS Project Manager.  The CMSIS-Pack files are typically not modified by an application programmer as they are provided by silicon vendors, board manufacturers, or the software industry.

The project setup uses YML Format. A schema file can add validation and "intellisense" during editing.

Project Files     | Order of processing and description
:-----------------|:---------------------------------------------------------------------------------
`*.csettings.yml` | 1. Default setup for project creation. For example, could provide build-types and a default board.
`*.csolution.yml` | 2. Container for related projects or image.
`*.cproject.yml`  | 3. Build description of an project that creates an independent image.
`*.clayer.yml`    | 4. Set of source files along with pre-configured components for reuse in different context.

The **CMSIS Project Manager** uses these *Project Files* along with the software packs in *CMSIS-Pack Format* to generate:
  - `*.cproject.yml` output files that contain the effective setting. When comparing to a previous generated version, this file shows the effective changes done by a user compared to the previous setup.
  - `*.cprj` files for CMSIS-Build where a reproducible build can be deployed to different host computers, for example a CI system.  It lists all packs, software components, etc. to recreate this project.
  - `script files` that are generated by a template engine (CMSIS-Zone concept) to setup linker and other application parameters (to be investigated).


# Project Examples

## Minimal Project Setup

Simple applications require just one self-contained file.

**Simple Project: `Sample.cproject.yml`**
```yml
project:
  compiler: AC6                    # Use Arm Compiler 6 for this project
  device: LPC55S69                 # Device name
  optimize: size                   # Code optimization: emphasis code size
  debug: on                        # Enable debug symbols

  groups:                          # Define file groups of theproject
    - group: My files           
      files:                       # Add source files
        - file: main.c

    - group: HAL
      files:
        - file: ./hal/driver1.c

  components:                      # Add software components
    - component: Device:Startup
```

## Project Setup for Multiple Targets and Test Builds

Complex examples require frequently slightly different targets and/or modifications during build, i.e. for testing. The picture below shows a setup during software development that supports:
 - Unit/Integration Testing on simulation models (call Virtual Hardware) where Virtual Drivers implement the interface to simulated I/O.
 - Unit/Integration Testing the same software setup on a physical board where Hardware Drivers implement the interface to physical I/O.
 - System Testing where the software is combined with more software components that compose the final application.

 ![Target and Build Types](./images/TargetBuild-Types.png "Target and Build Types")

As the software may share a large set of common files, provisions are required to manage such projects.  The common way in other IDE's is to add:
  - **target-types** that select a target system. In the example this would be:
    - `Virtual`: for Simulation Models.
    - `Board`: for a physical evaluation board.
    - `Production-HW`: for system integration test and the final product delivery.
  - **build-types** add the flexibility to configure each target build towards a specific testing.  It might be:
    - `Debug`: for a full debug build of the software for interactive debug.
    - `Test`: for a specific timing test using a test interface with code maximal optimization.
    - `Release`: for the final code deployment to the systems.

It is required to generate reproducible builds that can deployed on independent CI/CD test systems. To achieve that, *.the CMSIS Project Manager generates *.cprj output files with the following naming conventions:

`<projectname>[.<build-type>][+target-type].cprj` this would generate for example: `Multi.Debug+Production-HW.cprj`

This enables that each target and/or build type can be identified and independently generated which provides the support for test automation. It is however not required to build every possible combination, this should be under user control.

**Flexible Builds: `Multi.cproject.yml`**

```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32L552XY         # specifies device

  - type: Virtual
    board: VHT-Corstone-300     # Virtual Hardware platform (appears as board)
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on

  - type: Release
    optimize: max
    debug: off

groups:
  - group: My group1
    files:
      - file: file1a.c
      - file: file1b.c
      - file: file1c.c

  - group: My group2
      - file: file2a.c

  - group: Test-Interface
    for-type: .Test
      - file: fileTa.c

layers:
  - layer: NUCLEO-L552ZE-Q/Board.clayer.yml   # tbd find a better way: i.e. $Board$.clayer.yml
    for-type: +Board

  - layer: Production.clayer.yml              # added for target type: Production-HW
    for-type: +Production-HW

  - layer: Corstone-300/Board.clayer.yml      # added for target type: VHT-Corstone-300
    for-type: +VHT-Corstone-300

components:
  - component: Device:Startup
  - component: CMSIS:RTOS2:FreeRTOS
  - component: ARM::CMSIS:DSP&Source          # not added for build type: Test
    not-for-type: .Test                           
```

## Project Setup for Related Projects

A solution is the software view of the complete system. It combines projects that can be generated independently and therefore manages related projects. It may be also deployed to different targets during development as described in the previous section under [Project Setup for Multiple Targets and Test Builds](#project-setup-for-multiple-targets-and-test-builds).

The picture below shows a system that is composed of:
  - Project A: that implements a time-critical control algorithm running on a independent processor #2.
  - Project B: which is a diagram of a cloud connected IoT application with Machine Learning (ML) functionality.
  - Project C: that is the data model of the Machine Learning algorithm and separate to allow independent updates.
  - Project D: that implements the device security (for example with TF-M that runs with TrustZone in secure mode).

In addition such systems may have a boot-loader that can be also viewed as another independent project.

![Related Projects of an Embedded System](./images/Solution.png "Related Projects of an Embedded System")

To manage the complexity of such related a projects, the `*.csolution.yml` file is introduced. At this level the `target-types` and `build-types` may be managed, so that a common set is available across the system. However it should be also possible to add project specific `build-types` at project level.  (tdb: `target-types` might be only possible at solution level).

**Related Projects `iot-product.csolution.yml`**

```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32U5X          # specifies device
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on
    
solution:
  - project: /security/TFM.cproject.yml
    type: .Release
  - project: /application/MQTT_AWS.cproject.yml
  - project: /bootloader/Bootloader.cproject.yml
    not-for-type: +Virtual
```

# Name Conventions

## Component Names

The CMSIS Project Manager uses the following syntax to specify component names:

```
[Cvendor::] Cclass [&Cbundle] :Cgroup [:Csub] [&Cvariant] [@[>=]Cversion]
``` 

Element    | Description
:----------|:---------------------
`Cvendor`  | is the name of the component vendor defined in <components> element of the software pack (optional).
`Cclass`   | is the component class name  defined in <components> element of the software pack (required)
`Cbundle`  | is the bundle name of component class defined in <bundle> element of the software pack (optional).
`Cgroup`   | is the component group name  defined in <components> element of the software pack (required).
`Csub`     | is the component sub-group name  defined in <components> element of the software pack (optional).
`Cvariant` | is the component sub-group name  defined in <components> element of the software pack (optional).
`Cversion` | is the version number of the component, with @1.2.3 that must exactly match, or @>=1.2.3 that allows any version higher or equal.

**Notes:**

  - The unique separator `::` allows it to omit `Cvendor`
  - When `Cvariant` is omitted, the default `Cvariant` is selected.


**Examples:**

```yml
ARM::CMSIS:CORE                           # CMSIS Core component from vendor ARM (any version)
ARM::CMSIS:CORE@5.5.0                     # CMSIS Core component from vendor ARM (with version 5.5.0)
ARM::CMSIS:CORE@>=5.5.0                   # CMSIS Core component from vendor ARM (with version 5.5.0 or higher)

Device:Startup                            # Device Startup component from any vendor

CMSIS:RTOS2:Keil RTX5                     # CMSIS RTOS2 Keil RTX5 component with default variant (any version)
ARM::CMSIS:RTOS2:Keil RTX5&Source@5.5.3   # CMSIS RTOS2 Keil RTX5 component with variant 'Source' and version 5.5.3

Keil::USB&MDK-Pro:CORE&Release@6.15.1     # From bundle MDK-Pro, USB CORE component with variant 'Release' and version 6.15.1

```

## Access Sequences

The following **Access Sequences** allow to use arguments from the CMSIS Project Manager in *key* and *value* arguments of the various `*.yml` files.


Access Sequence             | Description
:---------------------------|:--------------------------------------
`$Bname$`                   | Board name of the selected board.
`$Bpack$`                   | Path to the pack that defines the selected board (BSP).
`$Dname$`                   | Device name of the selected device.
`$Dpack$`                   | Path to the pack that defines the selected device (DFP).
`$Pack$`                    | Path to the CMSIS Pack Root directory.
`$Pack(vendor.name)$`       | Path to specific pack with latest version. Example: `$Pack(NXP.K32L3A60_DFP)$`.
`$Output(project)$`         | Output file of a related project that is defined in the `*.csolution.yml` file.

ToDo: define directory structure; should we use `$Output(project[.build-type][+target-type])$`

**Examples:**

```yml
groups:
  - group:  "Main File Group"
    defines:
      - $Dname$                           # Generate a #define 'device-name' for this file group
```
```yml
  - execute: Generate Image
    os: Windows                           # on Windows run from
    run: $DPack$/bin/gen_image.exe        # DFP the get_image tool
```      



# YML Syntax

## Overall Structure

Keyword          | Allowed for following files..                  | Description
:----------------|:-----------------------------------------------|:------------------------------------
`default:`       | `[defaults].csettings.yml`, `*.csolution.yml`  | Start of the default section with [General Properties](#general-properties)
`target-types:`  | `*.csolution.yml`                              | Start of the [Target type declaration list](#target-and-build-types) that allow to switch between [different targets](#project-setup-for-multiple-targets-and-test-builds).
`build-types:`   | `[defaults].csettings.yml`, `*.csolution.yml`  | Start of the [Build type declaration list](#target-and-build-types) that allow to switch between different build settings such as: Release, Debug, Test.
`solution:`      | `*.csolution.yml`                              | Start of the [Collection of related Projects](#solution-collection-of-related-projects) along with build order.
`project:`       | `*.cproject.yml`                               | Start of a Project along with properties - tbd; used in `*.cproject.yml`.
`layer:`         | `*.clayer.yml`                                 | Start of a software layer definition that contains pre-configured software components along with source files.
`groups:`        | `*.cproject.yml`, `*.clayer.yml`               | Start of a list that adds [source groups and files](#groups-and-files) to a project or layer.
`layers:`        | `*.cproject.yml`                               | Start of a list that adds software layers to a project.
`components:`    | `*.cproject.yml`, `*.clayer.yml`               | Start of a list that adds software components to a project or layer.

**Note:** For stand-alone `*.cproject.yml` files that do not required a `*.csolution.yml` it is possible to use the *Keywords* that are allowed at `*.csolution.yml` file level.

## General Properties

The keywords below can be used at various levels in this file types: `[defaults].csettings.yml`, `*.csolution.yml`, and `*.cproject.yml`. 

Keyword         | Description
:---------------|:------------------------------------
`compiler:`     | Selection of the toolchain used for the project, i.e. `GCC`, `AC6`, `IAR`, optional with version, i.e AC6@6.16-LTS
`device:`       | Unique device name, optionally with vendor and core. Format: `[<vendor>::]<device>[:<core>]`.  When `device:` is null the device is derived from the `board:` device setting, but `device:` overrules the `board:` device setting.
`board:`        | Unique board name, optionally with vendor. Format: `[<vendor>::]<board>`. Examples: `NXP::LPCxpresso55S69` or `NUCLEO-L552ZE-Q`.
`optimize:`     | Generic optimize levels (max, size, speed, debug), mapped to the toolchain by CMSIS-Build.
`debug:`        | Generic control for the generation of debug information (on, off), mapped to the toolchain by CMSIS-Build.
`warnings:`     | Control warnings (could be: no, all, Misra, AC5-like), mapped to the toolchain by CMSIS-Build.
`defines:`      | [#define symbol settings](#defines) for the code generation tools.
`undefines:`    | [Remove #define symbol settings](#undefines) for the code generation tools.
`add-paths:`    | [Add include path settings](#add-paths) for the code generation tools.
`del-paths:`    | [Remove include path settings](#del-paths) for the code generation tools.
`misc:`         | [Miscellaneous literal tool-specific controls](#misc) that are passed directly to the tools depending on the file type.

**Notes:**
 - `defines:`, `add-paths:`  and `misc:` are additive. All other keywords overwrite previous settings.

## Target and Build Types

The section [Project setup for multiple targets and test builds](#project-setup-for-multiple-targets-and-test-builds) describes the concept of  `target-types` and `build-types`.  These *types* can be defined in the following files in the following order:
 1.  `default.csettings.yml`  where it defines global *types*, such as *Debug* and *Release* build.
 2. `*.csolution.yml` where it specifies the build and target *types* of the complete system.
 3. `*.cproject.yml` where it may add specific *types* for an project (tbd are target types allowed when part of a solution?)

The *`target-type`* and *`build-type`* definitions are additive, but an attempt to redefine an already existing type results in an error.

The settings of the *`target-type`* are processed first; then the settings of the *`build-type`* that potentially overwrite the *`target-type`* settings.


YML structure:
```yml
target-types:          # Start a list of target type declarations
  - type:              # name of the target type (required)
    board:             # board specification (optional)
    device:            # device specification (optional)         
    processor:         # processor specific settings (optional)
    compiler:          # toolchain specification (optional) 
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # define symbol settings for code generation (optional).
    undefines:         # remove define symbol settings for code generation (optional).
    add-paths:         # additional include file paths (optional).
    del-paths:         # remove specific include file paths (optional). 
    misc:              # Literal tool-specific controls

build-types:           # Start a list of build type declarations
  - type:              # name of the build type (required)
    processor:         # processor specific settings (optional)
    compiler:          # toolchain specification (optional) 
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # define symbol settings for code generation (optional).
    undefines:         # remove define symbol settings for code generation (optional).
    add-paths:         # additional include file paths (optional).
    del-paths:         # remove specific include file paths (optional). 
    misc:              # Literal tool-specific controls
```


**Example:**
```yml
target-types:
  - type: Board
    board: NUCLEO-L552ZE-Q

  - type: Production-HW
    device: STM32U5X          # specifies device
      
build-types:
  - type: Debug
    optimize: debug
    debug: on

  - type: Test
    optimize: max
    debug: on
```

The `board:`, `device:`, and `processor:` settings are used to configure the code translation for the toolchain.  These settings are processed in the following order:

1. `board:` relates to a BSP software pack that defines board parameters, including the [mounted device](https://arm-software.github.io/CMSIS_5/Pack/html/pdsc_boards_pg.html#element_board_mountedDevice).  If `board:` is not specified, a `device:` most be specified.
2. `device:` defines the target device.  If `board:` is specified, the `device:` setting can be used to overwrite the device or specify the processor core used.
3. `processor:` overwrites default settings for code generation, such as endianess, TrustZone mode, or disable Floating Point code generation.

**Examples:**
```yml
target-types:
  - type: Production-HW
    board: NUCLEO-L552ZE-Q    # hardware is similar to a board
    device: STM32L552RC       # but uses a slightly different device
    processor: 
      trustzone: off          # TrustZone disabled for this project
```

```yml 
target-types:
  - type: Production-HW
    board: FRDM-K32L3A6       # NXP board with K32L3A6 device
    device: :cm0plus          # use the Cortex-M0+ processor
```



## Build/Target-Type control

Depending on a *`target-type`* or *`build-type`* selection it is possible to include or exclude *items* in the build process.

Keyword         | Description
:---------------|:------------------------------------
`for-type:`     | A *type list* that adds an *item* for a specific target or build *type* or a list of *types*.
`not-for-type:` | A *type list* that removes an *item* for a specific target or build *type* or a list of *types*.

It is possible to specify only a `<build-type>`, only a `<target-type>` or a combination of `<build-type>` and `<target-type>`. It is also possible to provide a list of *build* and *target* types. The *type list syntax* for `for-type:` or `not-for-type:` is:

`[.<build-type>][+<target-type>] [, [.<build-type>]+[<target-type>]] [, ...]`

**Examples:**
```yml
for-type:      .Test                            # add item for build-type: Test (any target-type)
not-for-type:  +Virtual                         # remove item for target-type: Virtual (any build-type)
not-for-type:  .Release+Virtual                 # remove item for build-type: Release with target-type: Virtual
for-type:      .Debug, .Release+Production-HW   # add for build-type: Debug and build-type: Release / target-type: Production-HW
```

The keyword `for-type:` or `not-for-type:` can be applied to the following list keywords:

Keyword      | Description
:------------|:------------------------------------
`project:`   | At `solution:` level it is possible to control inclusion of project.
`group:`     | At `group:` level it is possible to control inclusion of a file group.
`file:`      | At `file:` level it is possible to control inclusion of a file.
`layer:`     | At `layer:` level it is possible to control inclusion of a software layer.
`component:` | At `component:` level it is possible to control inclusion of a software component.


## Groups and Files

YML structure:
```yml
groups:                # Start a list of groups
  - group:             # name of the group
    for-type:          # include group for a list of *build* and *target* types.
    not-for-type:      # exclude group for a list of *build* and *target* types.
    optimize:          # optimize level for code generation (optional)
    debug:             # generation of debug information (optional)
    defines:           # define symbol settings for code generation (optional).
    undefines:         # remove define symbol settings for code generation (optional).
    add-paths:         # additional include file paths (optional).
    del-paths:         # remove specific include file paths (optional). 
    misc:              # Literal tool-specific controls
    groups:            # Start a nested list of groups
      - group:         # name of the group
         :
    files:             # Start a nested list of files
      - file:          # file name along with path
        for-type:      # include group for a list of *build* and *target* types.
        not-for-type:  # exclude group for a list of *build* and *target* types.
        optimize:      # optimize level for code generation (optional)
        debug:         # generation of debug information (optional)
        defines:       # define symbol settings for code generation (optional).
        undefines:     # remove define symbol settings for code generation (optional).
        add-paths:     # additional include file paths (optional).
        del-paths:     # remove specific include file paths (optional). 
        misc:          # Literal tool-specific controls.
```

**Example:**

Add source files to a project or a software layer.  Used in `*.cproject.yml` and `*.clayer.yml` files.

```yml
groups:
  - group:  "Main File Group"
    not-for-type: .Release+Virtual, .Test-DSP+Virtual, +Board
    files: 
      - file: file1a.c
      - file: file1b.c
        defines:
          - a: 1
        undefines:
          - b
        optimize: size

  - group: "Other File Group"
    files:
      - file: file2a.c
        for-type: +Virtual
        defines: 
          - test: 2
      - file: file2a.c
        not-for-type: +Virtual
      - file: file2b.c

  - group: "Nested Group"
    groups:
      - group: Subgroup1
        files:
          - file: file-sub1-1.c
          - file: file-sub1-2.c
      - group: Subgroup2
        files:
          - file: file-sub2-1.c
          - file: file-sub2-2.c
```

## Layers 

Add a software layer to a project.  Used in `*.cproject.yml` files.

YML structure:
```yml
layers:                # Start a list of layers
  - layer:             # path to the `*.clayer.yml` file that defines the layer (required).
    for-type:          # include layer for a list of *build* and *target* types (optional).
    not-for-type:      # exclude layer for a list of *build* and *target* types (optional).
    optimize:          # optimize level for code generation (optional).
    debug:             # generation of debug information (optional).
    defines:           # define symbol settings for code generation (optional).
    undefines:         # remove define symbol settings for code generation (optional).
    add-paths:         # additional include file paths (optional).
    del-paths:         # remove specific include file paths (optional). 
    misc:              # Literal tool-specific controls.
```

## Components

Add software components to a project or a software layer.  Used in `*.cproject.yml` and `*.clayer.yml` files.

YML structure:
```yml
components:            # Start a list of layers
  - component:         # name of the software component.
    for-type:          # include layer for a list of *build* and *target* types (optional).
    not-for-type:      # exclude layer for a list of *build* and *target* types (optional).
    optimize:          # optimize level for code generation (optional).
    debug:             # generation of debug information (optional).
    defines:           # define symbol settings for code generation (optional).
    undefines:         # remove define symbol settings for code generation (optional).
    add-paths:         # additional include file paths (optional).
    del-paths:         # remove specific include file paths (optional). 
    misc:              # Literal tool-specific controls.
```

**NOTE:**
 - The name of the software component is specified as described under [Name Conventions - 
Component Names](#Component_Names)


## Defines

Add symbol #define statements to the command line of the development tools.

YML structure:
```yml
defines:                   # Start a list of define statements
  - name: value            # add a symbol with optional value.
  - name:
```

## Undefines

Remove symbol #define statements from the command line of the development tools.

YML structure:
```yml
undefines:                 # Start a list of undefine statements
  - name                   # remove symbol from the list of define statements.
  - name                   # remove a symbol.
```

## Add-Paths

Add include paths to the command line of the development tools.

YML structure:
```yml
add-paths:                 # Start a list path names that should be added to the include file search
  - path                   # add path name
  - path
```

## Del-Paths

Remove include paths (that are defined at the cproject level) from the command line of the development tools.

YML structure:
```yml
del-paths:                 # Start a list of path names that should be removed from the include file search
  - path                   # remove path name
  - *                      # remove all paths
```



## Misc

Add tool specific controls as literal strings that are directly passed to the individual tools.

YML structure:
```yml
misc:                      # Start a list of literal control strings that are directly passed to the tools.
  - compiler:              # select the toolchain that the literal control string applies too (AC6, IAR, GCC).
    C: string              # applies to *.c files only.
    CPP: string            # applies to *.cpp files only.
    C*: string             # applies to *.c and *.cpp files.
    ASM: string            # applies to assembler source files
    Link: string           # applies to the linker
    Lib: string            # applies to the library manager or archiver
```


## Solution: Collection of related Projects

The section [Project setup for related projects](#project-setup-for-related-projects) describes the collection of related projects.  The file `*.csolution.yml` describes the relationship of this projects.  This file may also define [Target and Build Types](#target-and-build-types) before the section `solution:`.

The YML structure of the section `solution:` is:

```yml
solution:                  # Start a list of projects.
  - project:               # path to the project file (required).
    for-type:              # include project for a list of *build* and *target* types (optional).
    not-for-type:          # exclude project for a list of *build* and *target* types (optional).
    compiler:              # specify a specific compiler
    optimize:              # optimize level for code generation (optional)
    debug:                 # generation of debug information (optional)
    defines:               # define symbol settings for code generation (optional).
    undefines:             # remove define symbol settings for code generation (optional).
    add-paths:             # additional include file paths (optional).
    del-paths:             # remove specific include file paths (optional). 
    misc:                  # Literal tool-specific controls
```

## Project Definition

Start of a project definition in a `*.cproject.yml` file (optional section)

The YML structure of the section `project:` is:
```yml
project:                     # do we need this section at all, perhaps for platform?
  compiler: name             # specify compiler (AC6, GCC, IAR)
  description:               # project description (optional)
  processor:                 # specify processor  ??
  ....
```  


## Processor

The `processor:` keyword defines:
  - for multi-processor systems: the core that is used to execute the program part.
  - attributes such as trustzone and fpu register usage.

```yml
 processor:                # processor specific settings
    trustzone: secure      # TrustZone mode: secure | non-secure | off
    fpu: off               # control usage of FPU registers (S-Registers that are used for Helium and FPU hardware): on | off
    endian: little | big   # select endianess 
```

todo - where can `processor:` used?


# Pre/Post build steps

Tbd: potentially map to CMake add_custom_command.

```yml
- execute: description      # execute an external command with description
  os: Linux                 # executed on which operating systems (if omitted it is OS independent)
  run:                      # tool name that should be executed, optionally with path to the tool
  args:                     # tool arguments
  stop:                     # stop on exit code
```

Potential usage before/after build

```yml
solution:
  - execute: Generate Keys for TF-M
    os: Linux
    run: KeyGen.exe
  - project: /security/TFM.cproject.yml
  - project: /application/MQTT_AWS.cproject.yml
  - execute: Copy output files
    run: cp *.out .\output
```

Potential usage during build steps
```yml
groups:
  - group:  "Main File Group"
    files: 
      - execute: Generate file1a.c
        run: xyz.exe
        ....
      - file: file1a.c
```



## Layer Definition

Start of a layer definition in a `*.clayer.yml` file.

Todo: work on this

The YML structure of the section `layer:` is:
```yml
layer:
  description:
  ....
```  


# CMSIS-Zone Integration
Todo:



# Project Structure

## Directory Structure

This section describes how files of Software Component are included into the directory structure of the project:

 - Configurable source and header files are copied to the project using the directory structure explained below.
 - Libraries, source, and header files that are not configurable (and need no modification) are stored in the directory of the Software Component (typically part of CMSIS_Pack_ROOT) and get included directly from this location into the project.
 - An Include Path to the header files of the Software Component is added to the C/C++ Compiler control string.

The following directory and files are created in the Project Folder:

Directory                         | Content
:---------------------------------|:---------------
`./RTE/<target-type>`             | Contains the file `RTE_Components.h` that is specific to a `target-type`. 
`./RTE/<component class>`         | Configurable files for each component class are stored in sub-folders. The name of this sub-folder is derived from the component class name.
`./RTE/<component class>/<Dname>` | Configurable files of the component class that are device specific. It is generated when a component has a condition with a `Dname` attribute.
`./RTE/Device/<Dname>`            | Configurable files of the component class Device. This should have always a condition with a `Dname` attribute.

The directory `.\RTE` is created in the project root directory when using Software Components. You should not modify the content of this folder.

## RTE_Components.h

The file `./RTE/RTE_Components.h` is automatically created by the CMSIS Project Manager (during CONVERT). For each selected Software Component it contains `#define` statements required by the component. These statements are defined in the \*.PDSC file for that component. The following example shows a sample content of a RTE_Components.h file:

```
/* Auto generated Run-Time-Environment Component Configuration File *** Do not modify ! *** */

#ifndef RTE_COMPONENTS_H
#define RTE_COMPONENTS_H

/* Define the Device Header File: */
#define CMSIS_device_header "stm32f10x.h"

#define RTE_Network_Interface_ETH_0     /* Network Interface ETH 0 */
#define RTE_Network_Socket_BSD          /* Network Socket BSD */
#define RTE_Network_Socket_TCP          /* Network Socket TCP */
#define RTE_Network_Socket_UDP          /* Network Socket UDP */

#endif /* RTE_COMPONENTS_H */
```

The typical usage of the `RTE_Components.h` file is in header files to control the inclusion of files that are related to other components of the same Software Pack.
```
#include "RTE_Components.h"
#include  CMSIS_device_header

#ifdef  RTE_Network_Interface_ETH_0  // if component Network Interface ETH 0 is included
#include "Net_Config_ETH_0.h"        // add the related configuration file for this component
#endif
```
